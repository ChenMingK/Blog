# 操作系统的基本功能
1.进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

2.内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

3.文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

4.设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 系统调用
如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<img src="https://box.kancloud.cn/ef451c14976330fe87b927f3ecf92b3e_753x462.png" />

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :-: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |
# 进程与线程
## 进程
进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

## 线程
线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，
线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<img src="https://box.kancloud.cn/5634f78b408c9af61a6b09ded6ce8d39_390x227.png" />

## 区别
Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

更为具体地说，线程之间共享**堆**和**全局变量**，因为堆是在进程空间中开辟出来的，所以肯定是跨线程共享的；

同理，全局变量是整个程序所共享的，也应由线程共享。而每个线程都会独立地维护属于自己的**寄存器**与**栈**。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。

类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

具体来说，进程间通信一般有以下两种形式：1.共享内存 2.消息传递

<img src="https://box.kancloud.cn/205626c254a99da8601f95acbc6acbac_416x237.png" />

- 共享内存模式：建立一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。
- 消息传递模式：通过在协作进程间交换消息来实现通信。

# 程序在内存中的分布
<img src="https://box.kancloud.cn/2aa2c5448363da028708187afbfe4380_314x311.png" />

**代码段(.text)**：也称文本段(Text Segment)，存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。

**BSS段(.bss)**：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS 是英文 Block Started by Symbol 的简称。BSS 段属于静态内存分配。

**数据段(.data)**：数据段（data segment）通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配。

**堆（Heap）**：用来存储程序运行时分配的变量。堆的大小并不固定，可动态扩张或缩减。堆的内存的分配与释放由应用程序控制，通常申请的内存都需要释放，如果没有释放，在程序运行结束后操作系统会自动回收。

**栈（Stack）**：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。

- 所谓**动态存储区域**： 即 堆  栈  
- 所谓**静态存储区域**：即 存储静态变量和全局变量以及代码段的部分

# 死锁
## 必要条件
<img src="https://box.kancloud.cn/9ed12967b7661cc4db8c53d517448c00_560x255.png" />

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 死锁处理
主要有以下四种方法：
- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

### 鸵鸟策略
把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
### 死锁检测与死锁恢复
不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

<img src="https://box.kancloud.cn/b4ebd1a2eeb7bcf263c3f2a4a0ef5b1b_597x305.png" />

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，
如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。


### 死锁预防
在程序运行之前预防发生死锁。

1.破坏互斥条件

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

2.破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

3.破坏不可抢占条件

4.破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

### 死锁避免
在程序运行时避免发生死锁。使用银行家算法来保证资源的合理分配：[https://blog.csdn.net/qq\_37205708/article/details/86550339](https://blog.csdn.net/qq_37205708/article/details/86550339)

# 操作系统笔记十篇
[https://blog.csdn.net/qq\_37205708/article/category/8618355](https://blog.csdn.net/qq_37205708/article/category/8618355)
